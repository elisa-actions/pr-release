{"version":3,"file":"index.js","mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChFA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7BA;AACA;;;;;;ACDA;;AAEA","sources":["../webpack://pr-release-action/./src/comment.js","../webpack://pr-release-action/./src/create-release.js","../webpack://pr-release-action/./src/pr-release.js","../webpack://pr-release-action/./src/pr.js","../webpack://pr-release-action/./src/release-data.js","../webpack://pr-release-action/./src/release-notes.js","../webpack://pr-release-action/./src/update-tag.js","../webpack://pr-release-action/./src/version.js","../webpack://pr-release-action/../../../../../usr/local/Cellar/ncc/0.36.1/libexec/lib/node_modules/@vercel/ncc/dist/ncc/@@notfound.js","../webpack://pr-release-action/webpack/bootstrap","../webpack://pr-release-action/webpack/runtime/compat","../webpack://pr-release-action/./index.js"],"sourcesContent":["const core = require(\"@actions/core\");\nconst github = require(\"@actions/github\");\n\nasync function addCommentReaction(comment_id, reaction) {\n  const token = core.getInput(\"github_token\", { required: true });\n  const octokit = github.getOctokit(token);\n  const { owner, repo } = github.context.issue;\n  return await octokit.rest.reactions.createForIssueComment({\n    owner,\n    repo,\n    comment_id,\n    content: reaction,\n  });\n}\n\nasync function addComment(message) {\n  const token = core.getInput(\"github_token\", { required: true });\n  const octokit = github.getOctokit(token);\n  const { owner, repo, number } = github.context.issue;\n  return await octokit.rest.issues.createComment({\n    owner,\n    repo,\n    issue_number: number,\n    body: message,\n  });\n}\n\nmodule.exports = { addCommentReaction, addComment };\n","const core = require(\"@actions/core\");\nconst github = require(\"@actions/github\");\n\nasync function createRelease(version, commitSha, name, body, prerelease) {\n  const token = core.getInput(\"github_token\", { required: true });\n  const releaseDraft = core.getInput(\"release_draft\").toLowerCase() === 'true'\n  const preReleaseDraft = core.getInput(\"prerelease_draft\").toLowerCase() === 'true'\n  const octokit = github.getOctokit(token);\n  const { owner, repo } = github.context.repo;\n\n  const response = await octokit.rest.repos.createRelease({\n    owner,\n    repo,\n    tag_name: version,\n    target_commitish: commitSha,\n    name,\n    body,\n    draft: prerelease ? preReleaseDraft : releaseDraft,\n    prerelease,\n  });\n\n  core.setOutput(\"release_id\", response.data.id);\n  core.setOutput(\"release_url\", response.data.html_url);\n  core.setOutput(\"release_upload_url\", response.data.upload_url);\n  return response.data;\n}\n\nmodule.exports = createRelease;\n","const core = require(\"@actions/core\");\nconst github = require(\"@actions/github\");\nconst getNextVersion = require(\"./version\");\nconst getPR = require(\"./pr\");\nconst createReleaseData = require(\"./release-data\");\nconst createRelease = require(\"./create-release\");\nconst { addComment, addCommentReaction } = require(\"./comment\");\nconst updateMajorTag = require(\"./update-tag\");\n\nasync function run() {\n  try {\n    let prerelease = false;\n    let dry_run = core.getInput(\"dry_run\") === \"true\";\n    let commitSha = null;\n    if (github.context.payload.action === \"closed\") {\n      const pr = await getPR();\n      commitSha = pr.data.head.sha;\n      if (!pr.data.merged) {\n        console.log(`PR #${pr.data.number} was closed.`);\n        return;\n      }\n    } else if ([\"created\", \"edited\"].includes(github.context.payload.action)) {\n      const comment = github.context.payload[\"comment\"][\"body\"];\n      if (comment && comment.trim() === \"/prerelease\") {\n        prerelease = true;\n        const pr = await getPR();\n        commitSha = pr.data.head.sha;\n        await addCommentReaction(github.context.payload.comment.id, \"rocket\");\n      } else {\n        return;\n      }\n    } else if (dry_run) {\n      await getNextVersion(false);\n      return;\n    } else {\n      console.log(`Action ${github.context.payload.action} not supported`);\n      return;\n    }\n    // Check version\n    const version = await getNextVersion(prerelease);\n    if (!version) {\n      await addComment(\"New release not required :sparkles:\");\n      return;\n    }\n\n    // Build release data and expose as output variables\n    const releaseData = await createReleaseData();\n\n    // Create release\n    if (!dry_run) {\n      console.log(\"Create release\");\n      const release = await createRelease(\n        version.toString(),\n        commitSha,\n        releaseData.title,\n        releaseData.body,\n        prerelease\n      );\n      await updateMajorTag(version, commitSha);\n      await addComment(\n        `Version [${version}](${release.html_url}) ${\n          release.draft ? \"drafted\" : \"released\"\n        }! :zap:`\n      );\n    }\n  } catch (error) {\n    console.trace();\n    console.log(error);\n    core.setFailed(error.message);\n  }\n}\n\nmodule.exports = run;\n","const core = require(\"@actions/core\");\nconst github = require(\"@actions/github\");\n\nasync function getPR() {\n  const token = core.getInput(\"github_token\", { required: true });\n  const octokit = github.getOctokit(token);\n  const { owner, repo, number } = github.context.issue;\n  const pr = await octokit.rest.pulls.get({\n    owner,\n    repo,\n    pull_number: number,\n  });\n  return pr;\n}\n\nmodule.exports = getPR;\n","const core = require(\"@actions/core\");\nconst github = require(\"@actions/github\");\nconst createReleaseNotes = require(\"./release-notes\");\n\nasync function createReleaseData() {\n  const token = core.getInput(\"github_token\", { required: true });\n  const includeReleaseNotes = (core.getInput(\"release_notes\").toLowerCase() || \"true\") === \"true\";\n  const octokit = github.getOctokit(token);\n  const { owner, repo, number } = github.context.issue;\n  const issue = await octokit.rest.issues.get({\n    owner,\n    repo,\n    issue_number: number,\n  });\n  const title = issue.data.title;\n  let body = issue.data.body || \"\";\n  body = removeDependabotInstructions(body);\n  if (includeReleaseNotes) {\n    body = body.concat(\"\\n\\n\", await createReleaseNotes());\n  }\n  core.setOutput(\"release_title\", title);\n  core.setOutput(\"release_body\", body);\n  return { title, body };\n}\n\nfunction removeDependabotInstructions(body) {\n  const instructionPosition = body.indexOf(\"Dependabot will resolve any conflicts with this PR\");\n  if (instructionPosition === -1) {\n    return body;\n  }\n  return body.substring(0, instructionPosition).trim();\n}\n\nmodule.exports = createReleaseData;\n","const core = require(\"@actions/core\");\nconst github = require(\"@actions/github\");\nlet conventionalCommitsParser = require(\"conventional-commits-parser\");\n\nconst commitHeaders = {\n  feat: \"Features\",\n  feature: \"Features\",\n  fix: \"Bug Fixes\",\n  \"fix(deps)\": \"Dependencies\",\n  perf: \"Performance Improvements\",\n  revert: \"Reverts\",\n};\n\nconst ignoreScopes = [\"fix(review)\"];\n\nasync function createReleaseNotes() {\n  const token = core.getInput(\"github_token\", { required: true });\n  const octokit = github.getOctokit(token);\n  if (github.context.issue) {\n    const { owner, repo, number } = github.context.issue;\n    const commits = await octokit.rest.pulls.listCommits({\n      owner,\n      repo,\n      pull_number: number,\n      per_page: 100,\n    });\n    const releaseNotes = {\n      Features: [],\n      \"Bug Fixes\": [],\n      Dependencies: [],\n      \"Performance Improvements\": [],\n      Reverts: [],\n    };\n    commits.data.forEach(function (item) {\n      const parsedCommit = conventionalCommitsParser.sync(item.commit.message);\n      console.log(parsedCommit);\n      const scopedType = parsedCommit.scope\n          ? `${parsedCommit.type}(${parsedCommit.scope})`\n          : parsedCommit.type;\n      const header = scopedType in commitHeaders\n          ? commitHeaders[scopedType]\n          : commitHeaders[parsedCommit.type];\n      if (header && !ignoreScopes.includes(scopedType)) {\n        const scope = parsedCommit.scope ? `**${parsedCommit.scope}:** ` : \"\";\n        const message = `- ${scope}${parsedCommit.subject} [${item.sha.slice(\n          0,\n          6\n        )}](${item.html_url})`;\n        const notesArray = [];\n        if (parsedCommit.notes) {\n          parsedCommit.notes.forEach((note) =>\n            notesArray.push(`    **${note.title}** ${note.text}`)\n          );\n        }\n        const notes = notesArray.length ? `\\n${notesArray.join(\"\\n\")}` : \"\";\n        releaseNotes[header].push(message + notes);\n      }\n    });\n    const notesArray = [];\n    for (let [key, value] of Object.entries(releaseNotes)) {\n      if (value.length) {\n        notesArray.push(\n          `<details><summary><strong>${key}</strong></summary><p>\\n`\n        );\n        value.forEach((message) => notesArray.push(message));\n        notesArray.push(\"\\n</p></details>\");\n      }\n    }\n    return notesArray.join(\"\\n\");\n  }\n}\n\nmodule.exports = createReleaseNotes;\n","const core = require(\"@actions/core\");\nconst github = require(\"@actions/github\");\nconst semver = require(\"semver\");\n\nasync function updateMajorTag(version, sha) {\n  if (core.getInput(\"update_major_tag\") !== \"true\" || semver.prerelease(version)) {\n    return;\n  }\n  const token = core.getInput(\"github_token\", { required: true });\n  const octokit = github.getOctokit(token);\n  const majorVersion = semver.major(version);\n  const majorTag = `v${majorVersion}`;\n  const { owner, repo } = github.context.repo;\n\n  try {\n    await octokit.rest.git.getRef({\n      owner,\n      repo,\n      ref: `tags/${majorTag}`,\n    });\n    await octokit.rest.git.updateRef({\n      owner,\n      repo,\n      sha,\n      ref: `tags/${majorTag}`,\n      force: true,\n    });\n  } catch {\n    // ref didn't exist\n    await octokit.rest.git.createRef({\n      owner,\n      repo,\n      ref: `refs/tags/${majorTag}`,\n      sha,\n    });\n  }\n}\n\nmodule.exports = updateMajorTag;\n","const core = require(\"@actions/core\");\nconst github = require(\"@actions/github\");\nconst semver = require(\"semver\");\nconst { analyzeCommits } = require(\"@semantic-release/commit-analyzer\");\n\nconst cwd = process.cwd();\nconst PRERELEASE_ID_MAX_LENGTH = 10;\n\nasync function getNextVersion(prerelease) {\n  const token = core.getInput(\"github_token\", { required: true });\n  const octokit = github.getOctokit(token);\n  const { owner, repo, number } = github.context.issue;\n  const { data: commits } = await octokit.rest.pulls.listCommits({\n    owner,\n    repo,\n    pull_number: number,\n    per_page: 100,\n  });\n  const commitMessages = commits.map((commit) => commit.commit.message);\n\n  const { data: refs } = await octokit.rest.git\n    .listRefs({\n      ...github.context.repo,\n      namespace: \"tags/\",\n    })\n    .catch(() => {\n      return { data: [] };\n    });\n  console.log(refs);\n  const versions = refs\n    .map((ref) =>\n      semver.parse(ref.ref.replace(/^refs\\/tags\\//g, \"\"), { loose: true })\n    )\n    .filter((version) => version !== null)\n    .sort(semver.rcompare);\n  const latestRelease =\n    versions.filter((version) => semver.prerelease(version) === null)[0] ||\n    semver.parse(\"0.0.0\");\n  console.log(`Latest release is \"${latestRelease.toString()}\"`);\n\n  const identifier = core.getInput(\"prerelease_id\", { required: false }) || \"\";\n  if (identifier.length > PRERELEASE_ID_MAX_LENGTH) {\n    core.setFailed(\"prerelease_id is too long\");\n    return null;\n  }\n  const bump = await getBumpLevel(commitMessages, prerelease);\n  if (!bump) {\n    core.setOutput(\"version\", null);\n    core.setOutput(\"bump\", null);\n    return null;\n  }\n  console.log(`Bumping with ${bump}`);\n\n  let version = semver.inc(latestRelease, bump, identifier);\n  while (versions.filter((v) => v.version === version).length === 1) {\n    version = semver.inc(version, \"prerelease\");\n  }\n  core.setOutput(\"version\", version.toString());\n  core.setOutput(\"bump\", bump);\n  return version;\n}\n\nasync function getBumpLevel(commitArray, prerelease) {\n  const commits = commitArray.map((message, index) => ({\n    hash: index.toString(),\n    message,\n  }));\n  const releaseType = await analyzeCommits(\n    {\n      preset: \"conventionalcommits\",\n    },\n    { cwd, commits, logger: console }\n  );\n\n  if (releaseType && prerelease) {\n    return \"pre\" + releaseType;\n  }\n  return releaseType;\n}\n\nmodule.exports = getNextVersion;\n",null,"// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\nif (typeof __webpack_require__ !== 'undefined') __webpack_require__.ab = __dirname + \"/\";"],"names":[],"sourceRoot":""}